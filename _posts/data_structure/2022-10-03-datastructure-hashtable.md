---
title:  "[Data Sturcture] 해시 테이블(Hash Table)에 대해 알아보자❗️"

categories:
- Data Structure
tags:
- [Hash Table, Data Structure]

toc: true
toc_sticky: true

date: 2022-10-03
last_modified_at: 2022-10-11
---

## 해시 테이블(Hash Table)이란? 🔎

### 1. 정의 🔎

- (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조
- 해시 테이블이 빠른 검색 속도를 제공하는 이유
    - 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이다.
- 해시 테이블은 각각의 Key값에 해시 함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다.
    - 버킷 or 슬롯 : 실제 값이 저장되는 장소

<br>

---

<br>

### 2. 특징 🔎

1. 기본 연산으로는 search, insert, delete가 있다.
2. 순차적으로 데이터를 저장하지 않는다.
3. key를 통해서 value를 얻을 수 있다. → 이진 탐색 트리나 배열에 비해서 속도가 획기적으로 빠르다.
4. 커다란 데이터를 해시해서 짧은 길이로 축약할 수 있기 때문에 데이터를 비교할 때 효율적이다.
5. value는 중복이 가능하지만 key는 Unique해야 한다.
6. 수정 가능하다.
7. 보통 배열로 미리 Hash Table Size만ㅋ큼 생성 후에 사용한다.

<br>

---

<br>

### 3. 장점 🔎

1. 다량의 데이터를 적은 리소스로 관리할 수 있어 효율적이다.

- 하드 디스크나 클라우드에 존재하는 무한에 가까운 데이터(Key)들을 유한한 개수의 해시 값으로 Mapping함으로써 작은 크기의 캐시 메모리로도 프로세스를 관리할 수 있게 된다.

2. index에 해시 값을 사용해서 모든 데이터를 살피지 않아도 삽입/삭제을 편하게 수행할 수 있다.
3. 언제나 동일한 해시 값을 리턴하고, 해당 index만 알면 해시테이블의 크기에 상관없이 데이터에 빠르게 접근할 수 있으며, 인덱스는 계산이 간단한 함수(상수시간)로 작동하기 때문에 매우 효율적이다. 다시 말해,
   데이터 액세스 시 계산복잡성으로 0(1)을 지향한다.
4. 키와 해시값 사이에 직접적인 연관이 없기 때문에 해시값만 가지고는 키를 온전히 복원하기 어려워 보안 분야에서 널리 사용된다.
5. 길이가 서로 다른 입력데이터에 대해 일정한 길이의 출력을 만들 수 있어서 데이터를 축약할 수도 있다.

<br>

---

<br>

### 4. 단점 🔎

1. 해시 테이블에서의 연산은 평균적으로 일정한 시간이 걸리지만 좋은 해시 함수의 비용은 순차 목록 또는 검색 트리에 대한 검색 알고리즘의 내부 루프보다 상당히 클 수 있다.

- 따라서 해시 테이블은 항목 수가 매우 적으면 유효하지 않는다.(해시 함수를 계산하는데 드는 비용은 해시 값을 키와 함께 저장하여 완화할 수 있다.)

2. 맞춤법 검사와 같은 특정 문자열 처리 응용 프로그램의 경우 해시테이블은 트리, 유한 오토마타 또는 주디 배열보다 효율적이지 않을 수 있다.

- 또한 저장할 수 있는 키가 너무 많지 않은 경우 즉, 각 키를 충분히 작은 비트수로 표현할 수 있는 경우 해시테이블 대신 키를 배열의 인덱스로 직접 사용할 수 있다. 이 경우에는 충돌이 발생하지 않는다.

3. 해시테이블에 저장된 항목은 효율적으로(항목 당 일정한 비용으로) 열거되지만 의사 임의의 순서로만 열거 할 수 있다.

- 따라서 키가 지정된 키와 가장 가까운 항목을 찾는 효율적인 방법은 없다. 특정 순서로 모든 n개 항목을 나열하려면 일반적으로 비용이 항목 당 log(n)에 비례하는 별도의 정렬 단계가 필요하다.

4. 작업당 평균 비용이 일정하고 상당히 작지만, 단일 작업의 비용은 상당히 높을 수 있다.
5. 해시테이블은 일반적으로 참조의 지역성이 낮다. 즉, 액세스 할 데이터는 임의로 메모리에서 무작위로 분산되어 있다. 해시테이블이 액세스 패턴을 야기하기 때문에 긴 지연을 유발하는 마이크로 프로세서 캐시 미스가
   발생할 수 있다.
6. 해시테이블은 많은 충돌이 있을 때 매우 비효율적이다. 극단적으로 고르지 않은 해시 분포가 우연히 발생 할 가능성은 거의 없지만 해시 함수에 대해 잘 알고 있는 악의적인 공격자는 과도한 충돌로 인해 최악의 행동을
   일으키는 정보를 해시에 제공할 수 있다.

<br>

---

<br>

### 5. 해시 값이 충돌하는 경우 🔎

- 이에 대한 해결법은 크게 분리 연결법(Separate Chaining)과 개방 주소법(Open Addressing)으로 해결하고 있다. <br>

#### 1. 분리 연결법(Separate Chaining)

![image](https://user-images.githubusercontent.com/61777583/194982730-d7ce86a9-d243-485a-82c0-d4e2a4026026.png)

- 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다.
  위의 그림과 같이 동일한 버킷으로 접근을 한다면 데이터들을 연결을 해서 관리해주고 있다. 실제로 Java8의 Hash테이블은 Self-Balancing Binary Search Tree 자료구조를 사용해
  Chaining 방식을 구현하였다.

#### 2. 개방 주소법(Open Addressing)

- 비어있는 해시 테이블의 공간을 활용하는 방법
- 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.
    1. Linear Probing(선형 탐사법) : 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어있는 버킷에 데이터를 저장한다.
    2. Quadratic Probing(제곱 탐사법) : 해시의 저장순서 폭을 제곱으로 저장하는 방식이다.

    - ex) 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식

    3. Double Hashing Probing(이중 해싱) : 해시된 값을 한 번 더 해싱하여 해시의 규칙성을 없애버리는 방식

    - 해시된 값을 한 번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

![image](https://user-images.githubusercontent.com/61777583/194984259-03c7fd82-bceb-44c7-a924-93dd5b2c11b0.png)

- 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 Hash Table을 재정리 해주는 작업이 필요하다.

<br>

---

<br>

### 6. 시간 복잡도 🔎

- 각각의 Key값은 해시 함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간복잡도로 데이터를 조회할 수 있다. 하지만 데이터의 충돌이 발생한 경우 Chaining에 연결된
  리스트들까지 검색을 해야 하므로 O(N)까지 시간복잡도가 증가할 수 있다.
- 충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만 공간을 많이 사용한다는 치명적인 단점이 있다.
- 만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확정을 하지 않도록 테이블을 설계해주어야 한다.
    - (통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)
- 또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

### Java의 해시 맵(Hash Map)과 해시 테이블(Hash Table)의 차이

- 동기화 지원 여부
- 병렬 처리를 하면서 자원의 동기화를 고려해야 하는 상황 → 해시 테이블
- 병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황 → 해시 맵

<br>

---

<br>

### 7. 활용 🔎

1. 연관배열

- 해시 테이블은 일반적으로 여러 유형의 메모리 내 테이블을 구현하는데 사용된다. 특히, 루비, 파이썬, PHP와 같은 해석된 프로그래밍 언에서 연관배열(지표가 임의의 문자열 또는 기타 복잡한 객체인 배열)을
  구현하는데 사용된다.

2. 데이터베이스 색인화

- 해시테이블은 디스크 기반 데이터 구조 및 데이터베이스 인덱스(예:dbm)로도 사용될 수 있지만 B- 트리는 이러한 응용 프로그램에서 더 많이 사용된다. 다중 노드 데이터베이스 시스템에서 해시테이블은 일반적으로
  노드 사이에 행을 분산하는 데 사용되어 해시조인에 대한 네트워크 트래픽을 줄인다.

3. 캐시

- 해시테이블은 느린 미디어에 주로 저장된 데이터에 대한 액세스 속도를 높이기 위해 사용되는 캐시, 보조 데이터 테이블을 구현하는데 사용할 수 있다. 이 응용 프로그램에서는 충돌하는 두 항목 중 하나를 삭제하여
  해시충돌을 처리할 수 있다. 일반적으로 현재 테이블에 저장된 이전 항목을 지우고 새 항목으로 덮어 쓰므로 테이블의 모든 항목은 고유한 해시값을 갖는다.

4. 세트

- 주어진 키를 가지고 있는 항목을 복구하는 것 외에도, 많은 해시테이블 구현들은 그러한 항목이 존재 여부를 구별할 수 있다. 따라서 이러한 구조는 특정 키가 특정 키 집합에 속하는지 여부를 기록하는 세트 데이터
  구조를 구현하는 데 사용될 수 있다. 이 경우 입력값과 관련된 모든 부분을 제거함으로써 구조를 단순화 할 수 있다. 해시는 정적 집합과 동적 집합을 구현하는 데 사용될 수 있다.

5. 개체 표현

- 펄, 파이썬, 자바스크립트, 루아, 루비와 같은 몇몇 동적 언어는 해시테이블을 사용하여 개체를 구현한다. 이 표현에서 키는 개체의 구성원과 메소드의 이름이며, 값은 해당 구성원이나 메소드에 대한 포인터가 된다.

6. 독특한 데이터 표현

- 해시테이블은 같은 내용을 가진 다중 문자열 생성을 피하기 위해 일부 프로그램에서 사용할 수 있다. 이를 위해 프로그램에서 사용중인 모든 문자열은 해시테이블로 구현된 단일 문자열 풀에 저장되며, 이 문자열 풀은 새
  문자열을 만들어야 할 때마다 확인된다. 이 기법은 해시컨설팅이라는 이름으로 Lisp 인터프리터에 도입되었으며, 다른 많은 종류의 데이터(심볼릭 대수 시스템의 표현트리, 데이터베이스의 레코드, 파일 시스템의 파일,
  이진법 결정 다이어그램 등)와 함께 사용할 수 있다.

<br>

---

<br>

###### Reference

- https://mangkyu.tistory.com/102
- https://velog.io/@edie_ko/hashtable-with-js
- http://wiki.hash.kr/index.php/%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94
- https://code-lab1.tistory.com/14

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right} 